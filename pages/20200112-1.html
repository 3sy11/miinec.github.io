<!doctype html>
<html class="no-js" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<title>米de世界</title>
		<meta name="description" content="">
		<meta name="author" content="Miinec">

		<link rel="stylesheet" href="/theme/css/foundation.css" />
		<link rel="stylesheet" href="/theme/css/pygment/monokai.css" />
		<link rel="stylesheet" href="/theme/css/custom.css" />


		<script src="/theme/js/modernizr.js"></script>

		<!-- Feeds -->


		<!-- mathjax config similar to math.stackexchange -->
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			jax: ["input/TeX", "output/HTML-CSS"],
			tex2jax: {
				inlineMath: [ ['$', '$'] ],
				displayMath: [ ['$$', '$$']],
				processEscapes: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
			},
			messageStyle: "none",
			"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
		});
		</script>
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	</head>
	<body>
		<div class="off-canvas-wrap">
			<div class="inner-wrap">
				<!-- mobile top bar to activate nav -->
				<nav class="tab-bar show-for-small">
					<section class="left-small">
						<a class="left-off-canvas-toggle menu-icon" ><span></span></a>
					</section>

					<section class="middle tab-bar-section">
						<h1 class="title">米de世界</h1>
					</section>
				</nav>

				<!-- mobile side bar nav -->
				<aside class="left-off-canvas-menu">
					<ul class="off-canvas-list">
						<li><a href="">Home</a></li>
						<li><label>Categories</label></li>
							<li ><a href="/category/du-shu-bi-ji.html">读书笔记</a></li>
							<li ><a href="/category/ji-zhu.html">技术</a></li>
							<li class="active"><a href="/category/ji-zhu-wen-zhang.html">技术文章</a></li>
							<li ><a href="/category/jing-ji-he-jin-rong.html">经济和金融</a></li>
							<li ><a href="/category/kuang-jia-he-gong-ju.html">框架和工具</a></li>
							<li ><a href="/category/shang-ye.html">商业</a></li>
							<li ><a href="/category/she-hui-ke-xue.html">社会科学</a></li>

						<li><label>Links</label></li>



						<li><label>Social</label></li>
							<li><a href="http://github.com/miinec/">github</a></li>
					</ul>	
				</aside>

				<!-- top bar nav -->
				<nav class="top-bar hide-for-small-only" data-topbar>
					<ul class="title-area">
						<li class="name">
							<h1><a href="/">米de世界</a></h1>
						</li>
					</ul>

					<section class="top-bar-section">
						<ul class="left">
								<li ><a href="/category/du-shu-bi-ji.html">读书笔记</a></li>
								<li ><a href="/category/ji-zhu.html">技术</a></li>
								<li class="active"><a href="/category/ji-zhu-wen-zhang.html">技术文章</a></li>
								<li ><a href="/category/jing-ji-he-jin-rong.html">经济和金融</a></li>
								<li ><a href="/category/kuang-jia-he-gong-ju.html">框架和工具</a></li>
								<li ><a href="/category/shang-ye.html">商业</a></li>
								<li ><a href="/category/she-hui-ke-xue.html">社会科学</a></li>
						</ul>
                        <ul class="right">                                                                                                                                           
                                                                                                                                             
                        </ul>  
					</section>
				</nav>

				<!-- Main Page Content and Sidebar -->
				<section class="main-section">
					<div class="row">
						<!-- Main Content -->
						<div class="medium-9 small-12 columns" role="content">
<article>
	<h2>软件交付的演进历程</h2>
	<p>2020-01-12 <a href="https://www.infoq.cn/article/P290jducMT3xzx9exYel">原文</a></p>
<h2>开始阶段</h2>
<p>软件开发刚开始的时候，并没有很好的经验或思想来指导一个开发项目的运行。最开始，人们标识出软件开发的一些关键假设，映射到那时已有的可理解的流程上。</p>
<p>最初的假设如下：</p>
<ol>
<li>软件开发需要很长的时间</li>
<li>软件发布不会频繁</li>
<li>软件构建后很难进行更改，所以确保第一次把事情做对</li>
<li>软件开发需要很多不同的、成本高昂的技能集</li>
</ol>
<p>建筑行业也有着类似的假设。建筑需要很长的时间，竣工后不能简单的添加一层或把面积扩大。建筑也涉及到很多不同的专业，从设计师到开发商，到质量监理以及工人、电工和水暖工等等。从这些角色的命名可以看出，软件开发从建筑行业借鉴了很多。</p>
<p>建筑行业遵循的流程是，把端到端的项目分成不同的阶段，每个流程阶段由不同的专业人士来负责。这种在每个阶段赋予角色的做法有利于充分利用成本高昂的人力资源。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/27/60/27cb6df0029a1a7828029e0a255ce960.jpeg"></p>
<p>瀑布流程</p>
<p>这看起来是一个很棒的流程。瀑布模型在 20 世纪 60 年代后期开始采用，直到 80 年代中期它才成为事实上的软件交付标准。但在流程执行中出现了些问题。根据<a href="https://www.projectsmart.co.uk/white-papers/chaos-report.pdf">2014 问题报告</a>，31% 的瀑布项目在投入很多后被取消，更有 52% 的项目预算需要翻倍。</p>
<p>鉴于这种很低的成功概率，很多人开始各自提出新的、更好的方式来交付项目，以克服瀑布流程中的一些缺陷。</p>
<h2>敏捷开发</h2>
<p>人们不希望看到自己的工作被废弃掉，因此最初的一个思想是把大型项目分解成小的部分，逐步迭代出解决方案。这种方法让人们能对产品随时间的进展有更直观的印象，让团队可以收集反馈来看产品是否已经解决用户的问题。这种早期的反馈让团队按需进行纠正。</p>
<p>但是<strong>从瀑布模型转型到迭代交付很难，很多组织就把迭代开发解释成随时间增量交付解决方案</strong>。敏捷这个术语很灵活，按照设计，并没有什么敏捷流程——其关注点在于小型迭代、持续学习和反应性。尽管流程很容易遵守和实现，不过这些软技能很难掌握。对流程阐述不够，会让人们绕开一些比较困难的变革，实现“对他们有效”的敏捷流程，并起一个引人注目的名字，如 Wagile 或 WaterScrumFall。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/9e/46/9e3524416886de81f143b782b8904146.jpeg"></p>
<p>更好的透明度限制了出现严重超限的风险，但是它没有解决导致瀑布项目高失败率的根本问题。仍然有项目会花费比预期长的时间来进行构建，有些项目会因为不能交付预期价值的产品被取消。</p>
<p>为了实现到迭代交付的飞跃，我们需要改变对软件交付的假设。我们要承认，我们前期不知道要构建的产品是什么样的，因此我们需要将<strong>预先大量设计（Big Design Up Front，BDUF）阶段替换成增量设计</strong>。</p>
<p>这样可以让团队有能力在项目开展过程中进行学习，并在需要的时候改变设计。这里的挑战是，设计阶段是保证项目团队内外进行协调的关键阶段，并汇总实现解决方案所需的各种时间估计。一个公司的各个流程不是孤立的，所以要改变一个流程，就会影响另外一个看起来好像没有关联的流程。比如，从 BDUF 中得到的估计，会被其他支撑流程所需要，如资金、监管、资源分配和环境分配等等。</p>
<p>采用这些“对我们有效的敏捷”中的问题是，没有认识到或解决我们对软件交付做出的假设和现有情况的冲突。</p>
<p>假设</p>
<ol>
<li>软件开发需要很长的时间</li>
<li>软件发布不会频繁</li>
<li><strong><em>软件构建后很难进行更改，所以确保第一次把事情做对</em></strong></li>
<li><strong>前期不可能确切知道要构建成什么样的产品，因此把大型开发分解为小部分，并在项目进行中不断学习</strong></li>
<li>软件开发需要很多不同的、成本高昂的技能集</li>
</ol>
<p>如果前期并不能确切知道要构建怎样的产品，我们怎么才能做到一次把事情做对呢？软件的大设计和最终产品经常有很大的出入——这就产生了不能预期的挑战，即要求设计根据不断出现的新需求进行调整。这说明，和建筑行业不一样，软件的变更在构建后并不困难，不需要像实体建筑那样前期做缜密的设计。我们可以简单的添加（软件）层数，改变层高或是扩大面积，而不需要推倒重来。因此，假设 2 实际是不正确的。</p>
<h2>（真正的）敏捷开发</h2>
<p>如果设计可以随着迭代过程中的学习进行更改，那么只做每次迭代所需的设计就会有利于减少可能的返工。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/c5/e2/c5f3cb8eab1fe5a293442442ff6f44e2.jpeg"></p>
<p>这其实是最难的一步，因为它不仅要求改变项目团队中的一些职能部门的工作方式，还包括支持部门工作方式的改变。</p>
<ol>
<li>我们没有足够的架构师，无法为每个团队都配备一个，指导他们进行持续的架构选择。架构师们需要定义好实践、原则和强制措施，确保设计符合指定的约束条件，而不是定义一个固定的架构。</li>
<li>开发工程师们将被赋予更多的责任。他们要完成针对问题给出最佳解决方案的任务，而不仅仅是按照需求规格说明书进行软件构建。架构师们不再面对交付的挑战，因此他们的假设经常不正确。最前线的开发人员在面临挑战时往往能提出更好的解决方案。</li>
<li>不进行预先的大量设计，就很难预估时间和成本。在瀑布项目里，时间和成本是基于项目启动时的估计确定的。在增量开发中，项目范围会根据实际遇到的新情况进行调整。时间和成本估计仍可以根据对交付的大致理解和团队规模进行，不过因为项目范围会有变化，投资回报率（ROI）和价值实现进度（benefits realisation schedule）无法在前期给出。</li>
</ol>
<p>现在，我们再更新下我们的假设。</p>
<ol>
<li>软件开发需要很长的时间</li>
<li>软件发布不会频繁</li>
<li>~~Software is hard to change after you build it so make sure you get it right first time~~</li>
<li>前期不可能确切知道要构建成什么样的产品，因此把大型开发分解为小部分，并在项目进行中不断学习</li>
<li>软件开发需要很多不同的、成本高昂的技能集</li>
<li><strong>实现团队负责在一定的边界条件下进行设计</strong></li>
</ol>
<h2>持续集成</h2>
<p>迭代交付的好处很大程度上是因为它可以获得关于产品的早期反馈。为了获取这些反馈，需要有一个软件的工作版本，解决了客户的问题，能够进行演示，并获得实际的反馈。为了交付这样一个软件版本，主要有两个挑战需要克服——软件开发怎样进行优先排序和怎样进行测试。</p>
<p>传统的瀑布项目中，最有效的方法是按组件构建产品——构建完美的轮胎、完美的底盘，最后组装到汽车上。上下文切换会耗费时间，因此，切换越少就可以越高效地利用开发时间。这种组件开发方式在开发团队中根深蒂固，即使他们采用了敏捷开发，实际的构建方式仍相同。问题是，如果客户想从 A 点到 B 地点，而我们给客户展示的是一个完成了的车轮，客户没法给出任何有价值的反馈。这解决不了他们的问题。我们需要从基于组件的开发转换到迭代开发方式，这要求有一个思想上的转换，即关注于客户问题而不是解决方案。只有不再做预先的大量设计，并承认前期我们并不很清楚需要构建的是什么，这种转变才可能实现。但即使如此，团队仍需要培训，因为它会影响到需求文档的编写和开发的进行。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/ce/05/ce79c61ad06bdc617fade0f12a9bae05.png"></p>
<p>价值增量 (Courtesy of Henrik Kniberg)</p>
<p>第一，开发人员的时间是软件开发中一项很高的成本，产品定义改变是否值得呢？除了 31% 的失败率，<a href="https://ai.stanford.edu/~ronnyk/ExPThinkWeek2009Public.pdf">微软的分析</a>指出，高达 66% 的功能没有实现预定的商业价值。考虑到失败率，确保我们是否做对了事情远比开发效率更重要。我们会很快回到这一点，因为它即将影响到我们的下一个假设。</p>
<p>第二个挑战是关于测试的。为了得到有价值的反馈，我们需要让软件在客户面前工作起来，而不仅只作为演示。但是这需要测试，要花费很多时间和努力来完成的一项工作。过去，只在每次大的发布上执行一次测试，则自动化测试用例并不划算。但是有两件事改变了测试的这种情况。第一，现在的软件为商业的各个环节所需要，过去那种一年花很多天进行一次发布的情况已经不见了。第二，和开发人员的时间一样，项目中最大的浪费就是开发了错误的东西，而自动化测试让我们可以更频繁的测试客户的想法，它带来的益处超过了其成本。自动化测试周期让团队在整个开发过程中，可以持续开发“可发布”的代码。100% 的自动化测试是个很难达到的目标，因此在软件发布前还有会小量的手动验收测试，但其质量已经足够验证解决方案。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/56/3b/56bded92126b8f5dcf9083d4788c893b.jpeg"></p>
<p>瀑布流程中，保证不同团队高效是一个很关键的假设，这样才能降低成本。但是对于软件，因为软件发布频率增大，效率的经济性也随之发生了改变。现在的重点是保证端到端流程的有效性，而不再是保证每个职能部门的高效。这对软件来说并不新鲜——这种方法和技术是直接从精益生产运动中借鉴过来的。</p>
<h2>持续交付 / 部署 (DevOps)</h2>
<p>持续集成的好处在于代码在任何阶段都是可供部署的。这样即使项目即将被叫停，我们也有可部署的代码。不过和前面提到的测试一样，部署代码成本高而且耗时多。</p>
<p>即使软件已经就绪，人们仍然需要一些时间在环境间移动代码并完成部署步骤。而且软件还可能遇到新的问题，比如负载性能差。所以你以为软件已经可以发布了，但实际不是。</p>
<p>越早发现软件问题，解决的成本就越低。所以理想情况下，团队应该在每次迭代结束后，发现是否有非功能性需求的问题需要解决。手动部署占用时间很长，因此部署也应该自动化。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/c7/cc/c7b138ee75a2ef2b446fd5a4841996cc.jpeg"></p>
<p>持续交付缩减了代码发布的时间，但有时可能不需要发布。比如，你可能只完成了某个特性的一半，那么在第二个迭代完成后发布也是合理的。</p>
<p>了解整个部署阶段有助于我们发现问题，所以应该更频繁的进行部署。这样就引入了功能发布控制（feature toggles / feature flags）。在标识后面开发新功能，这样我们可以部分发布已完成的功能，但让它们处于关闭状态。用户甚至都不会意识到这些新功能，但我们可以测试到，这些代码不会对其它部分造成破坏。</p>
<p>功能发布控制还有其它的好处。将功能置于一个动态的转换中，我们可以开始在测试环境下进行 A/B 测试和多元测试，进而更精确的量化出变更的效果，这可以让我们更精准的验证我们对于客户的假设，必要时进行修正。我们可以动态打开或关闭某个功能，因此可以在生产环境进行用户验收测试，从而节省时间和成本。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/98/85/98f5e740660ed9fc7135627e7e0db385.jpeg"></p>
<p>经过这些变化后，我们再来回顾下我们的假设。</p>
<p>团队将交付时间从几个月缩减到几天，到一天几次。我们真的不能说软件开发花费很长的时间。如果它花的时间不长，我们是否能让专业人员分布到不同的阶段呢——每天怎样对多个阶段进行管理？我们没有减少所需的技能集，因此我们仍然需要架构师、业务分析师、手动测试工程师、自动化测试工程师、开发人员、运营人员、安全、管道开发人员等等。每个人只贡献一小部分，因此我们不需要让这些人员一直在一个团队，这样成本太高了。但同样的，我们不能让他们独立于团队之外，因为这样响应会太慢。如之前描述的架构师一样，确定边界和限制后，部分角色不再需要很深地介入到项目。然而，项目其他人员将要承担更多的责任。这类人员被称为 T 型人才。他们在某个领域有很深的专业知识（“|”），同时对其它领域有广博的了解，（“–”）。广博的知识面让他们在没有全职人员参与的领域内，也可以解决相关的问题。</p>
<h3>假设</h3>
<ol>
<li>~~Software development takes a long time~~</li>
<li>~~Software releases are infrequent~~</li>
<li><strong>软件发布可以很快很频繁</strong></li>
<li>~~Software is hard to change after you build it so make sure you get it right first time~~</li>
<li>前期不可能知道确切知道要构建成什么样的产品，因此把大型开发分解为小部分，并在项目进行中不断学习</li>
<li>~~Software development requires a number of distinct, expensive, skill sets~~.</li>
<li><strong>持续交付中，T 型人才是最有效的</strong></li>
<li>实现团队需要在已定义的边界下<strong>负责设计、开发和发布</strong></li>
</ol>
<h2>持续价值（Continuous Value）</h2>
<p>如果我们快速迭代地进行发布，那么如何进行完工定义？如果我们有既定的范围和时间，这个问题很简单。现在，我们要随时部署代码，什么东西会妨碍我们这样做？我们怎么才知道什么时候产品已经足够好呢?</p>
<p>如果软件交付不再需要很长时间，它就给我们打开了一个实验和验证的世界。</p>
<p>相应的，这也允许我们确认每次小的迭代的效果是否能达到用户的需求和我们的业务底线。</p>
<p>业务流程被相互协调的团队所代替，这些团队必须交付业务所需的产品。该团队实验并迭代需要开发的产品理念，从而确保可以达成既定的目标。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/9e/62/9eb9caab6b40041c7373114939200d62.jpeg"></p>
<p>该结构确保持续的交付来验证我们的尝试，但是仍存在一些效率低下的情况，因为在产品 / 用户体验 / 设计和实现团队之间，可能缺乏一致性。这种隔离通常被归类为“业务”（定义需开发产品的范围）和“IT”（做实际的交付工作）。这意味着只有一半的团队真正负责完成目标，另一半则作为交付的工具。我们仍需进行从交付物到交付业务成果的思想转变。</p>
<ul>
<li>Implementation teams need to take responsibility for the outcomes that they deliver</li>
</ul>
<h2>产品团队</h2>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/30/40/3091351b5baf217f7599af97f4f0f040.jpeg"></p>
<p>我们将有一个真正的跨职能产品团队，挖掘需求，交付产品，为客户和业务创造成果。让开发工程师在概念阶段就介入进来，可以集思广益，还能对交付它们的复杂度提供输入信息。设计人员自始至终参与到开发团队中，可以更好地了解设计对于客户的影响。</p>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/d4/3d/d42474c3ee4bbdb61a8f6838c898833d.png"></p>
<p>为了全面从瀑布项目已经定义好的阶段迁移到产品团队的持续流中，需要不断的尝试和创新，从而消除可能遇到的阻碍。但是万事都在变化中。团队随着产品需求不断成长，包括市场、客服和运维。流程的演进从不停止。我会增加最后一个假设：最好的流程来源于持续的反馈和尝试</p>
<h2>这些会把我们带向何方</h2>
<p>流程是很神奇的。当做一些重复性工作时，清晰的流程可以帮助我们明确需要做什么，需要避免那些已知的错误。在大型公司里，流程制度化是更有效的做事方式。<br>
但有时候这也会有问题。Jeff Bezos 在其第一天理论中指出了这点：</p>
<p>“好的流程为我们服务，进而为客户服务。但是，如果我们不保持警惕，流程就会成为问题。流程成了你希望获得的结果的替代品。”</p>
<p>所有流程的通病是它们包含了流程建立之初的假设和限制。随着时间迁移，那些已经嵌入流程之中的最初假设被遗忘了。问题在于，假设和限制不再有意义时，流程会阻碍我们的工作。</p>
<p>我们来看看下面的假设，看看哪一种描述对我们现在的工作状态描述更准确。</p>
<table>
<thead>
<tr>
<th></th>
<th>项目</th>
<th>产品</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间</td>
<td>软件开发需要很长时间 软件发布不频繁</td>
<td>软件交付快速且频繁</td>
</tr>
<tr>
<td>设计</td>
<td>软件在构建后很难变更，因此确保第一次把事情做对</td>
<td>前期不可能知道确切知道要构建成什么样的产品，因此把大型开发分解为小部分，并在项目进行中不断学习</td>
</tr>
<tr>
<td>团队</td>
<td>定义不同的角色，有效利用成本高昂的技术人员</td>
<td>持续交付中，跨团队的 T 型人才是最有效的</td>
</tr>
<tr>
<td>目标</td>
<td>实现团队对输出负责</td>
<td>实现团队对结果负责</td>
</tr>
<tr>
<td>流程</td>
<td>流程变更集中化，并在组间同步推进</td>
<td>根据持续的反馈和实践，流程可以在团队进行变更</td>
</tr>
</tbody>
</table>
<p>做这种转变并不容易，我在接下来的文章中会深入探讨，为了支持产品团队的转变，整个组织需要做那些相应改变，包括：</p>
<ul>
<li>管理层 / 组织架构变化</li>
<li>监管层变化</li>
<li>财务制度变化</li>
<li>用户体验和设计变化</li>
<li>开发变化</li>
<li>测试变化</li>
</ul>
<p><img alt="软件交付的演进历程" src="https://static001.infoq.cn/resource/image/8e/39/8e8ee1fa9b53c7c3bc197172fe0fd039.jpeg"></p>
	<hr/>
	<h6>Written by <a href="/author/mii.html">Mii</a> in <a href="/category/ji-zhu-wen-zhang.html">技术文章</a> on 周日 12 一月 2020. Tags: <a href="/tag/xiang-mu-guan-li.html">项目管理</a>, </h6>
</article>

<hr/>
						</div>
						<!-- End Main Content -->
						<!-- Sidebar -->
						<aside class="medium-3 hide-for-small-only columns">
							<div class="panel">
								<h5>Links</h5>
								<ul class="side-nav">
								</ul>
							</div>

							<div class="panel">
								<h5>Tags</h5>
								<ul class="tag-cloud">
									<li><a href="/tag/微服务.html" class="tag-4">微服务</a></li>
									<li><a href="/tag/信息论.html" class="tag-4">信息论</a></li>
									<li><a href="/tag/框架.html" class="tag-4">框架</a></li>
									<li><a href="/tag/docker.html" class="tag-4">docker</a></li>
									<li><a href="/tag/架构.html" class="tag-2">架构</a></li>
									<li><a href="/tag/系统.html" class="tag-4">系统</a></li>
									<li><a href="/tag/社交.html" class="tag-4">社交</a></li>
									<li><a href="/tag/内容.html" class="tag-4">内容</a></li>
									<li><a href="/tag/货币.html" class="tag-4">货币</a></li>
									<li><a href="/tag/交易.html" class="tag-4">交易</a></li>
									<li><a href="/tag/复杂系统.html" class="tag-4">复杂系统</a></li>
									<li><a href="/tag/规范.html" class="tag-4">规范</a></li>
									<li><a href="/tag/资讯.html" class="tag-4">资讯</a></li>
									<li><a href="/tag/crm.html" class="tag-4">CRM</a></li>
									<li><a href="/tag/控制论.html" class="tag-4">控制论</a></li>
									<li><a href="/tag/生态.html" class="tag-4">生态</a></li>
									<li><a href="/tag/django.html" class="tag-4">django</a></li>
									<li><a href="/tag/产品.html" class="tag-1">产品</a></li>
									<li><a href="/tag/中间件.html" class="tag-4">中间件</a></li>
									<li><a href="/tag/营销.html" class="tag-2">营销</a></li>
									<li><a href="/tag/文化.html" class="tag-4">文化</a></li>
									<li><a href="/tag/redis.html" class="tag-4">redis</a></li>
									<li><a href="/tag/容器化.html" class="tag-4">容器化</a></li>
									<li><a href="/tag/宏观经济.html" class="tag-4">宏观经济</a></li>
									<li><a href="/tag/心理.html" class="tag-4">心理</a></li>
									<li><a href="/tag/工业互联网.html" class="tag-4">工业互联网</a></li>
									<li><a href="/tag/政治.html" class="tag-4">政治</a></li>
									<li><a href="/tag/python.html" class="tag-2">python</a></li>
									<li><a href="/tag/设计.html" class="tag-2">设计</a></li>
									<li><a href="/tag/金融.html" class="tag-4">金融</a></li>
									<li><a href="/tag/数据.html" class="tag-4">数据</a></li>
									<li><a href="/tag/期权定价.html" class="tag-4">期权定价</a></li>
									<li><a href="/tag/理论.html" class="tag-4">理论</a></li>
									<li><a href="/tag/方法论.html" class="tag-2">方法论</a></li>
									<li><a href="/tag/案例.html" class="tag-2">案例</a></li>
									<li><a href="/tag/系统论.html" class="tag-4">系统论</a></li>
									<li><a href="/tag/投资.html" class="tag-2">投资</a></li>
									<li><a href="/tag/政策.html" class="tag-4">政策</a></li>
									<li><a href="/tag/运维.html" class="tag-4">运维</a></li>
									<li><a href="/tag/项目管理.html" class="tag-4">项目管理</a></li>
								</ul>
							</div>


							<div class="panel">
								<h5>Social</h5>
								<ul class="side-nav">
									<li><a href="http://github.com/miinec/">github</a></li>
								</ul>
							</div>
						</aside>
						<!-- End Sidebar -->
					</div>

					<!-- Footer -->
					<footer class="row">
						<div class="medium-9 small-12">
							<hr/>
							<p class="text-center">Powered by <a href="http://getpelican.com">Pelican</a> and <a href="http://foundation.zurb.com/">Zurb Foundation</a>. Theme by <a href="http://hamaluik.com">Kenton Hamaluik</a>.</p>
						</div>
					</footer>
					<!-- End Footer -->
				</section>
				<a class="exit-off-canvas"></a>
			</div><!--off-canvas inner-->
		</div><!--off-canvas wrap-->

		<script src="/theme/js/jquery.js"></script>
		<script src="/theme/js/foundation.min.js"></script>
		<script>
			$(document).foundation();
		</script>
	</body>
</html>